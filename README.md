# memory-allocator-and-garbage-collector

The file golang.sv contains the parameterized code for memory allocation of various data structures, garbage collection of heap data structures, and the memory allocator and garbage collector implementation on physical arrays. Three data structures are considered: stack, heap, and queue.
Stack: Stack has been divided into two stacks. We call them Stack1 and Stack2. Stack1 is for static memory allocation, e.g., allocation of an integer (int x), and stack2 is for dynamic memory allocation, which will be used when the data storage is done in a heap. The address of the heap element will be stored in stack2. In stack 1, the data stored in stack 1 will be in a LIFO fashion, and there is a stack pointer for tracking the data. Stack1 also has the option of pushing and popping the data and retrieving the data from any given value of the stack pointer. One block of stack1 is 8 bits, so the data can be stored bytewise in stack1. For stack 2, the data will be stored when it is stored in a heap. The address of the particular block of the heap where the data is stored is taken, and the address is stored in stack 2. The allocation is not LIFO. This is done so that we can know the address of the heap to be removed during garbage collection.

Heap: The heap will be used for dynamic memory allocation. One element of the heap is 24 bits. The first byte from LSB is the heap header, which will store the necessary information about the heap element, and the other two bytes are for storing data in a heap. Bit 0 is to tell if the heap block is free or not (0 for free, 1 for not free), and bit 1 is to tell if the heap block is headed or not. The heap block is composed of either 1, 2, 3, or 4 elements. This is done to club elements in a heap to make a block and to store large values in a heap. For example, if a heap block comprises four elements, it can store up to eight bytes of data. This type of data storage also helps one heap point to another. As the maximum number of elements a heap can have is 4, one heap block can point to a maximum of 4 heap blocks. This will create a sort of tree structure. The depth of this tree can be as high as 10. For example, if we want to store the hexadecimal number 2A3F 4444 5F23 in a heap, then we need 3 heap elements and club these 3 heap elements to form a heap block. The first heap element will have the value 2A3F, and as it is the first heap element, the value of its head field (bit number 1) will be 1, signifying that it is the starting of the heap block, the second heap element will store the value 4444 in its data field, and the value of its head field will be 0, the third heap element will store the value 5F23 in its data field and the value of its head field will also be 0 signifying that it is not the starting of the heap block. Bits 2-4 indicate the number of elements in each heap block. If the heap block only has one element, the value will be 001, 010 for two elements, 011 for three elements, and 100 for four elements. Bits 5-6 are used to indicate the color of the heap element.00 means it is white color, 01 means it is grey color, and 11 means it is black. The color coding will be used later on in Golang's garbage collection. Bit number 7 is used to tell whether the heap element is referring to some other heap element. If the value is 1, it refers to some other heap element, and the address of the heap element to which it is corresponding will be stored in the data field of that heap element. We know that heap will form a tree-like data structure, and the address of the topmost node of that tree will be stored in stack 2. The heap values are stored in address-ordered best fit allocation and a bitmap allocation scheme, as indicated by the codes bestfit_gc2.sv and bitmap_golang.sv.scheme.

Queue: Queue is the simplest of all the corresponding three data structures, and the data storage is in FIFO fashion. It has two pointed limbs as well as a head and a tail. As the data is stored in the queue, the tail pointer is incremented by 1, and if we want to remove any data from the queue, the data corresponding to the front pointer is removed, and then it is incremented by 1.
So we can remove data from the heap and queue as needed, but for data removal from the stack, we use a method called garbage collection. In the data allocation process in a heap, there is a counter called heap_counter. Whenever any data is stored in any heap element, the counter gets incremented by 1, and when the value of the counter reaches 70% of the maximum allowed value in a heap, a signal called "garbage collection" is triggered, and garbage collection of heap data can take place.

How is garbage collection done?
In the file golang.sv, Golang's tricolor garbage collection method is used. This garbage collection method is concurrent, and the allocator can work simultaneously as the garbage collector. When the GC signal is triggered, the module of the golang's garbage collector is invoked. Initially, all the objects are white when they are allocated. First, stack 2 is scanned, and all the heap elements corresponding to the addresses mentioned in stack 2 are colored grey. Now, the heap is scanned for the elements colored grey, and it colors them black; if the heap element points to any other element, that element is colored grey. So now, this cycle repeats again and again till the heap is completed. Finally, the heap is scanned again, and all objects that are still white in color are garbage and are removed from the heap, while all objects that are black or grey are retained and colored white for the next garbage collection cycle. If any object is allocated when garbage collection is going on, then the object is colored grey and will be checked in the next garbage collection cycle.

Data structure storage in physical arrays:
The data stored in the memory allocation will be stored in physical arrays. Three types of physical arrays are being considered. 824 arrays are of type 1, in which allocation can be done across all three data structures: heap, stack, and queue. 100 arrays of type 2 allow for the allocation of a single stack. 100 arrays are of type 3, in which the only queue can be allocated. The 824 arrays of type 1 are 512 by 512 bits. There are 512 rows, each containing 512 bits. Row numbers 0 to 122 in each of the type 1 arrays will be considered for storing the stack 1 data structure. Row numbers 123–245 in each of the type 1 arrays will be considered for storing queue data structures. Row numbers 246–417 in each of the type 1 arrays will be considered for storing queue data structures. Row numbers 418–511 in each of the type 1 arrays will be used for storing values in stack 2. Row number 512 in each of the type 1 arrays will be used for other global and local registers that are used. The 100 arrays in type 2 are 256 rows, each containing 256 bits. Each of these rows is used in the allocation of stack1. The 100 arrays in type 3 have 256 rows, each containing 256 bits. Each of these rows is used in queue allocation. For stack 1, the allocation starts from row 0 of type 1 array 0. If row 0 is completely filled, the allocation is done from row 0 of array 1, and so on, to row 0 of type 1 array 823. If all the rows 0 of the 824 arrays are filled, then the allocation will be done from row 1 of type 1 array 0. Then it goes to row 1 of array 1, and so on, till all the rows of all the arrays corresponding to stack 1 of all the arrays are filled. Then the data is allocated from row 0 of type2 array 0, and then it goes to row 0 of type2 array 1, and it allocates in the same manner as it allocated stack values in the type1 arrays. The queue is allocated in the exact same way as the stack is allocated, the only difference being that the first allocation will be done on row 123 of type 1 array 0, and the last allocation on type 1 array will be done on array number 245. Then allocation will be done on type 3 row 0 of array 0, and it will go on until row 0 of type 3 array 99, then it will move on to row 1 of type 3 array 0, and so on.

The heap allocation is done only on the 824 type 1 arrays. To begin with, a fit allocation scheme is used to determine heap allocation. The allocation will start from row 0 of array 0, and it will determine when it will get the first free block of the required size. If it does not get any free heap blocks, it will move on to row 0 of array 1, and so on. Once it gets a free block, the value will be stored in the corresponding physical array, and if the heap is the topmost node of a tree, then the address of the heap block will be stored in the rows corresponding to stack 2 of the SAME ARRAY. The heap_counter is a 32-bit counter stored in row number 512 of each array, and it will count how many heap objects are allocated in that array during garbage collection. During garbage collection, the garbage objects will be processed in each array in parallel; this will happen in all 824 arrays in parallel.
